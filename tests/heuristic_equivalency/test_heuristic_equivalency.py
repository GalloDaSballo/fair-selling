from brownie import chain
from rich.console import Console

console = Console()

"""
    Evaluates the pricing quotes generated by the optimized (heuristic) version of the OnChainPricingMainnet
    in contrast to its legacy version. The new version should lead to the same optimal price while consuming
    less gas.

    Tests excluded from main test suite as core functionalities are not tested here. In order to add to test 
    suite, modify the file name to: `test_heuristic_equivalency.py`. Note that tested routes depend on current
    liquidity state and, if liquidity moves between protocols, some assertions may fail.
"""

### Test findOptimalSwap Equivalencies for different cases
def test_pricing_equivalency_uniswap_v2(weth, pricer, pricer_legacy):
  token = "0xBC7250C8c3eCA1DfC1728620aF835FCa489bFdf3" # some swap (GM-WETH) only in Uniswap V2  
  ## 1e18
  sell_count = 100000000
  sell_amount = sell_count * 1000000000 ## 1e9
      
  chain.snapshot() # To price under same chain conditions (just because)
  tx = pricer.findOptimalSwap(token, weth.address, sell_amount)
  assert tx.return_value[0] == 1 ## UNIV2  
  quote = tx.return_value[1]

  chain.revert()
  tx2 = pricer_legacy.findOptimalSwap(token, weth.address, sell_amount)
  assert tx2.return_value[0] == 1 ## UNIV2  
  quote_legacy = tx2.return_value[1]

  assert quote >= quote_legacy # Optimized quote must be the same or better
  assert tx.gas_used < tx2.gas_used

def test_pricing_equivalency_uniswap_v2_sushi(oneE18, weth, pricer, pricer_legacy):
  token = "0x2e9d63788249371f1DFC918a52f8d799F4a38C94" # some swap (TOKE-WETH) only in Uniswap V2 & SushiSwap
  ## 1e18
  sell_count = 5000
  sell_amount = sell_count * oneE18 ## 1e18

  chain.snapshot() # To price under same chain conditions (just because)
  tx = pricer.findOptimalSwap(token, weth.address, sell_amount)
  assert (tx.return_value[0] == 1 or tx.return_value[0] == 2) ## UNIV2 or SUSHI
  quote = tx.return_value[1]

  chain.revert()
  tx2 = pricer_legacy.findOptimalSwap(token, weth.address, sell_amount)
  assert (tx2.return_value[0] == 1 or tx2.return_value[0] == 2) ## UNIV2 or SUSHI
  quote_legacy = tx2.return_value[1]

  assert quote >= quote_legacy # Optimized quote must be the same or better
  assert tx.gas_used < tx2.gas_used

def test_pricing_equivalency_balancer_v2(oneE18, weth, aura, pricer, pricer_legacy):
  token = aura # some swap (AURA-WETH) only in Balancer V2
  ## 1e18
  sell_count = 2000
  sell_amount = sell_count * oneE18 ## 1e18
  
  chain.snapshot() # To price under same chain conditions (just because)
  tx = pricer.findOptimalSwap(token, weth.address, sell_amount)
  assert tx.return_value[0] == 5 ## BALANCER 
  quote = tx.return_value[1]

  chain.revert()
  tx2 = pricer_legacy.findOptimalSwap(token, weth.address, sell_amount)
  assert tx2.return_value[0] == 5 ## BALANCER  
  quote_legacy = tx2.return_value[1]

  assert quote >= quote_legacy # Optimized quote must be the same or better
  assert tx.gas_used < tx2.gas_used

def test_pricing_equivalency_balancer_v2_with_weth(oneE18, wbtc, aura, pricer, pricer_legacy):
  token = aura # some swap (AURA-WETH-WBTC) only in Balancer V2 via WETH in between as connector
  ## 1e18
  sell_count = 2000
  sell_amount = sell_count * oneE18 ## 1e18
    
  chain.snapshot() # To price under same chain conditions (just because)
  tx = pricer.findOptimalSwap(token, wbtc.address, sell_amount)
  assert tx.return_value[0] == 6 ## BALANCERWITHWETH  
  quote = tx.return_value[1]

  chain.revert()
  tx2 = pricer_legacy.findOptimalSwap(token, wbtc.address, sell_amount)
  assert tx2.return_value[0] == 6 ## BALANCERWITHWETH    
  quote_legacy = tx2.return_value[1]

  assert quote >= quote_legacy # Optimized quote must be the same or better
  assert tx.gas_used < tx2.gas_used

def test_pricing_equivalency_uniswap_v3(oneE18, weth, pricer, pricer_legacy):
  token = "0xf4d2888d29D722226FafA5d9B24F9164c092421E" # some swap (LOOKS-WETH) only in Uniswap V3
  ## 1e18
  sell_count = 600000
  sell_amount = sell_count * oneE18 ## 1e18
    
  chain.snapshot() # To price under same chain conditions (just because)
  tx = pricer.findOptimalSwap(token, weth.address, sell_amount)
  assert tx.return_value[0] == 3 ## UNIV3  
  quote = tx.return_value[1]

  chain.revert()
  tx2 = pricer_legacy.findOptimalSwap(token, weth.address, sell_amount)
  assert tx2.return_value[0] == 3 ## UNIV3    
  quote_legacy = tx2.return_value[1]

  assert quote >= quote_legacy # Optimized quote must be the same or better
  assert tx.gas_used < tx2.gas_used

def test_pricing_equivalency_uniswap_v3_with_weth(oneE18, wbtc, pricer, pricer_legacy):
  token = "0xf4d2888d29D722226FafA5d9B24F9164c092421E" # some swap (LOOKS-WETH-WBTC) only in Uniswap V3 via WETH in between as connector
  ## 1e18
  sell_count = 600000
  sell_amount = sell_count * oneE18 ## 1e18
    
  chain.snapshot() # To price under same chain conditions (just because)
  tx = pricer.findOptimalSwap(token, wbtc.address, sell_amount)
  assert tx.return_value[0] == 4 ## UNIV3WITHWETH  
  quote = tx.return_value[1]

  chain.revert()
  tx2 = pricer_legacy.findOptimalSwap(token, wbtc.address, sell_amount)
  assert tx2.return_value[0] == 4 ## UNIV3WITHWETH 
  quote_legacy = tx2.return_value[1]

  assert quote >= quote_legacy # Optimized quote must be the same or better, note the fixed pair in new version of univ3 pricer might cause some nuance there
  assert tx.gas_used < tx2.gas_used

def test_pricing_equivalency_almost_everything(oneE18, wbtc, weth, pricer, pricer_legacy):
  token = weth # some swap (WETH-WBTC) almost in every DEX, the most gas-consuming scenario
  ## 1e18
  sell_count = 10
  sell_amount = sell_count * oneE18 ## 1e18
    
  chain.snapshot() # To price under same chain conditions (just because)
  tx = pricer.findOptimalSwap(token, wbtc.address, sell_amount)
  assert (tx.return_value[0] <= 3 or tx.return_value[0] == 5) ## CURVE or UNIV2 or SUSHI or UNIV3 or BALANCER  
  quote = tx.return_value[1]

  chain.revert()
  tx2 = pricer_legacy.findOptimalSwap(token, wbtc.address, sell_amount)
  assert (tx2.return_value[0] <= 3 or tx2.return_value[0] == 5) ## CURVE or UNIV2 or SUSHI or UNIV3 or BALANCER  
  quote_legacy = tx2.return_value[1]

  assert tx2.return_value[0] == tx.return_value[0]
  assert quote >= quote_legacy # Optimized quote must be the same or better, note the fixed pair in new version of univ3 pricer might cause some nuance there
  assert tx.gas_used < tx2.gas_used


### Test specific pricing functions for different underlying protocols

def test_balancer_pricing_equivalency(oneE18, weth, usdc, pricer, pricer_legacy):  
  ## 1e18
  sell_amount = 1 * oneE18

  quote = pricer.getBalancerPriceAnalytically(weth.address, sell_amount, usdc.address)
  quote_legacy = pricer_legacy.getBalancerPrice(weth.address, sell_amount, usdc.address).return_value

  assert quote >= quote_legacy # Optimized quote must be the same or better

def test_balancer_pricing_with_connector_equivalency(wbtc, usdc, weth, pricer, pricer_legacy):  
  ## 1e8
  sell_count = 10
  sell_amount = sell_count * 100000000
    
  quote = pricer.getBalancerPriceWithConnectorAnalytically(wbtc.address, sell_amount, usdc.address, weth.address)
  quote_legacy = pricer_legacy.getBalancerPriceWithConnector(
    wbtc.address, 
    sell_amount, 
    usdc.address, 
    weth.address
  ).return_value

  assert quote >= quote_legacy # Optimized quote must be the same or better